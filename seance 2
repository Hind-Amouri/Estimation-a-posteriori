## SÃ©ance 2 : Ã‰tude du code adrs.py et RÃ©solution de l'Ã©quation

### Objectifs :
- RÃ©soudre l'Ã©quation \( u_t + v u_s - \nu u_{ss} + \lambda u = f(s) \)
- VÃ©rifier la convergence vers la solution stationnaire
- Calculer les erreurs \( L2 \) et \( H1 \)
- Ã‰tudier la condition CFL et implÃ©menter la condition aux frontiÃ¨res \( u_s(s=L) = 0 \)

### Maillage :
- DiscrÃ©tisation uniforme du domaine avec \( N \) points.

### SchÃ©ma numÃ©rique :
- ImplÃ©mentation du schÃ©ma explicite pour rÃ©soudre l'Ã©quation.
- Conditions initiales et aux limites.

### RÃ©sultats :
- TracÃ© des courbes de convergence et d'erreur pour diffÃ©rents maillages.
Contenu de la sÃ©ance 2 :
Ã‰tudier et comprendre le code adrs.py :

Le code rÃ©sout l'Ã©quation suivante :

ğ‘¢
ğ‘¡
+
ğ‘£
ğ‘¢
ğ‘ 
âˆ’
ğœˆ
ğ‘¢
ğ‘ 
ğ‘ 
+
ğœ†
ğ‘¢
=
ğ‘“
(
ğ‘ 
)
u 
t
â€‹
 +vu 
s
â€‹
 âˆ’Î½u 
ss
â€‹
 +Î»u=f(s)
Avec :

ğ‘£
=
1
v=1
ğœˆ
=
0.01
Î½=0.01
ğœ†
=
1
Î»=1
Domaine : 
ğ¿
=
1
L=1
Forme exacte de 
ğ‘¢
(
ğ‘ 
)
u(s) : Tu dois prendre 
ğ‘¢
(
ğ‘ 
)
=
exp
â¡
(
âˆ’
10
(
ğ‘ 
âˆ’
ğ¿
/
2
)
2
)
u(s)=exp(âˆ’10(sâˆ’L/2) 
2
 ), puis en dÃ©duire 
ğ‘“
(
ğ‘ 
)
f(s) Ã  partir de l'Ã©quation donnÃ©e.

ImplÃ©menter 
ğ‘“
(
ğ‘ 
)
f(s) dans le code adrs.py :

Pour dÃ©terminer 
ğ‘“
(
ğ‘ 
)
f(s), tu dois calculer la dÃ©rivÃ©e temporelle et spatiale de 
ğ‘¢
(
ğ‘ 
)
u(s) et les insÃ©rer dans lâ€™Ã©quation.
Ensuite, implÃ©mente 
ğ‘“
(
ğ‘ 
)
f(s) dans le code Ã  l'endroit oÃ¹ la force source est dÃ©finie.
VÃ©rification : AprÃ¨s l'implÃ©mentation de 
ğ‘“
(
ğ‘ 
)
f(s), il faut vÃ©rifier si le code retrouve bien la solution exacte 
ğ‘¢
ex
(
ğ‘ 
)
u 
ex
â€‹
 (s).
Maillage uniforme et convergence :

DiscrÃ©tise lâ€™intervalle 
[
0
,
ğ¿
]
[0,L] en 
ğ‘
N points uniformes avec un pas 
â„
=
ğ¿
/
(
ğ‘
âˆ’
1
)
h=L/(Nâˆ’1).
Pour vÃ©rifier la convergence vers la solution stationnaire, utilise un maillage de 100 points.
Trace la norme de la diffÃ©rence 
âˆ£
âˆ£
ğ‘¢
ğ‘›
+
1
âˆ’
ğ‘¢
ğ‘›
âˆ£
âˆ£
ğ¿
2
âˆ£âˆ£u 
n+1
 âˆ’u 
n
 âˆ£âˆ£ 
L2
â€‹
 , ce qui montrera la convergence vers la solution stationnaire.
Normes 
ğ¿
2
L2 et 
ğ»
1
H1 aprÃ¨s convergence :

Calcul des erreurs : AprÃ¨s la convergence, tu calculeras les normes 
ğ¿
2
L2 et 
ğ»
1
H1 entre la solution numÃ©rique et la solution exacte pour diffÃ©rents maillages (par exemple : 3, 5, 10, 50, 100 points).
Tracer lâ€™erreur : Trace les erreurs 
ğ¿
2
L2 et 
ğ»
1
H1 en fonction de 
â„
h.
Conditions aux limites :

ImplÃ©mente la condition 
ğ‘¢
ğ‘ 
(
ğ‘ 
=
ğ¿
)
=
0
u 
s
â€‹
 (s=L)=0 dans le code.
ImplÃ©mentation dans le code adrs.py :
1. Calcul de 
ğ‘“
(
ğ‘ 
)
f(s) :
Soit la solution exacte :

ğ‘¢
ex
(
ğ‘ 
)
=
exp
â¡
(
âˆ’
10
(
ğ‘ 
âˆ’
ğ¿
/
2
)
2
)
u 
ex
â€‹
 (s)=exp(âˆ’10(sâˆ’L/2) 
2
 )
Tu dois calculer les dÃ©rivÃ©es nÃ©cessaires :

ğ‘¢
ğ‘ 
=
âˆ’
20
(
ğ‘ 
âˆ’
ğ¿
/
2
)
exp
â¡
(
âˆ’
10
(
ğ‘ 
âˆ’
ğ¿
/
2
)
2
)
u 
s
â€‹
 =âˆ’20(sâˆ’L/2)exp(âˆ’10(sâˆ’L/2) 
2
 )
ğ‘¢
ğ‘ 
ğ‘ 
=
(
400
(
ğ‘ 
âˆ’
ğ¿
/
2
)
2
âˆ’
20
)
exp
â¡
(
âˆ’
10
(
ğ‘ 
âˆ’
ğ¿
/
2
)
2
)
u 
ss
â€‹
 =(400(sâˆ’L/2) 
2
 âˆ’20)exp(âˆ’10(sâˆ’L/2) 
2
 )
Pour trouver 
ğ‘“
(
ğ‘ 
)
f(s), substitue 
ğ‘¢
(
ğ‘ 
)
u(s), 
ğ‘¢
ğ‘ 
(
ğ‘ 
)
u 
s
â€‹
 (s), et 
ğ‘¢
ğ‘ 
ğ‘ 
(
ğ‘ 
)
u 
ss
â€‹
 (s) dans lâ€™Ã©quation :

ğ‘“
(
ğ‘ 
)
=
ğ‘¢
ğ‘¡
+
ğ‘£
ğ‘¢
ğ‘ 
âˆ’
ğœˆ
ğ‘¢
ğ‘ 
ğ‘ 
+
ğœ†
ğ‘¢
f(s)=u 
t
â€‹
 +vu 
s
â€‹
 âˆ’Î½u 
ss
â€‹
 +Î»u
Puis implÃ©mente cette expression dans le code.

2. Maillage uniforme :
Dans le code, tu peux crÃ©er un maillage uniforme comme suit :
N = 100  # Nombre de points
L = 1.0  # Longueur du domaine
h = L / (N - 1)  # Pas de maillage
s = np.linspace(0, L, N)  # Maillage uniforme

3. Tracer la convergence :
AprÃ¨s avoir rÃ©solu le problÃ¨me pour plusieurs itÃ©rations, trace la convergence 
âˆ£
âˆ£
ğ‘¢
ğ‘›
+
1
âˆ’
ğ‘¢
ğ‘›
âˆ£
âˆ£
ğ¿
2
âˆ£âˆ£u 
n+1
 âˆ’u 
n
 âˆ£âˆ£ 
L2
â€‹
  pour voir si la solution stationnaire est atteinte.

Exemple de code pour tracer la convergence :
norm_L2_diff = np.linalg.norm(u_next - u_prev)
plt.plot(time_steps, norm_L2_diff / np.linalg.norm(u_exact), label="Convergence L2")
plt.xlabel('Temps')
plt.ylabel('Convergence ||u^{n+1} - u^n||_{L2}')
plt.legend()
plt.show()
4. Calcul et tracÃ© des erreurs 
ğ¿
2
L2 et 
ğ»
1
H1 :
AprÃ¨s la convergence, tu peux comparer la solution numÃ©rique avec la solution exacte en calculant les normes 
ğ¿
2
L2 et 
ğ»
1
H1 pour diffÃ©rents maillages.

Exemple pour calculer la norme 
ğ¿
2
L2 :
error_L2 = np.sqrt(np.sum((u_exact - u_numeric)**2) * h)
Pour le tracÃ© des erreurs en fonction de 
â„
h : 
h_values = [h1, h2, h3, h4, h5]  # DiffÃ©rents pas de maillage
error_L2_values = [error_L2_h1, error_L2_h2, ...]
error_H1_values = [error_H1_h1, error_H1_h2, ...]

plt.plot(h_values, error_L2_values, label="Erreur L2")
plt.plot(h_values, error_H1_values, label="Erreur H1")
plt.xlabel('Pas de maillage (h)')
plt.ylabel('Erreur')
plt.legend()
plt.show()
5.Conditions de stabilitÃ© et schÃ©ma numÃ©rique :
DÃ©centrage et viscositÃ© numÃ©rique : Dans le code adrs.py, vÃ©rifie comment les termes du schÃ©ma numÃ©rique sont calculÃ©s et oÃ¹ la viscositÃ© numÃ©rique est ajoutÃ©e pour stabiliser le schÃ©ma. Cela se trouve gÃ©nÃ©ralement dans les chapitres du livre mentionnÃ©s (chapitres 10 et 12).
Condition CFL : Analyse comment la condition CFL est implÃ©mentÃ©e et quelles sont les conditions actuelles aux frontiÃ¨res.
